# Bài 3: Giới thiệu về PYTHON (tiếp)

![](https://laptrinhcanban.com/python/nhap-mon-lap-trinh-python/gioi-thieu-python/python-la-gi/Python.jpg)

Trong bài viết trước, chúng ta đã nắm được về các thành phần cơ bản trong Python bao gồm biến, các phép tính, các toán tử, cũng như làm quen với kiểu dữ liệu và cấu trúc dữ liệu cơ bản. Trong bài viết này, Zootopi sẽ cùng các bạn tìm hiểu về cách vận hành cũng như thứ tự thực thi của các đoạn mã 1 chương trình thông qua câu lệnh điều kiện, vòng lặp. Bên cạnh đó, Zootopi sẽ làm quen với hàm và cách để tạo ra hàm thông thường, hàm vô danh, và bao hàm.

## I. CÂU LỆNH TUẦN TỰ

Trong Python, các câu lệnh ta viết được thực thi một cách tuần tự từ trên xuống dưới, ví dụ:


```python
print('Hello')
print('everyone')
print('!')
```

    Hello
    everyone
    !


Trong ví dụ trên, 3 hàm `print()` là 3 hàm độc lập với nhau. Khi ta thực thi các câu lệnh này, máy tính sẽ dịch và trả về kết quả các câu lệnh này theo thứ tự chúng xuất hiện trong cell code. Câu lệnh nào xuất hiện trước sẽ trả về kết quả trước và nó sẽ chạy và trả về kết quả cho đến khi hết các dòng lệnh hoặc cho đến khi gặp lỗi.

***Đố vui***: In ra kết quả như sau:
```
*
**
***
****
*****
```

Để giải bài đố vui này, ta có thể có 1 số phương pháp như sau:

- Cách 1:


```python
print('*')
print('**')
print('***')
print('****')
print('*****')
```

    *
    **
    ***
    ****
    *****


- Cách 2:


```python
print('*')
print('*'*2)
print('*'*3)
print('*'*4)
print('*'*5)
```

    *
    **
    ***
    ****
    *****


- Cách 3:


```python
print('*\n**\n***\n****\n*****')
```

    *
    **
    ***
    ****
    *****


Có thể thấy các dòng cần in ra có cùng 1 đặc trưng như sau:
- Các dòng đều chứa kí tự `*`
- Số kí tự `*` của dòng sau nhiều hơn dòng trước 1 đơn vị.

Vậy liệu có cách nào để ta có thể thực hiện được bài đố vui trên chỉ với 1 hoặc 2 dòng lệnh ngay cả khi số lượng dòng cần in ra theo đặc trưng trên nhiều hơn? Hãy cũng nhau đến với vòng lặp. 

## II. VÒNG LẶP

### 1. Vòng lặp `for`

`for` là 1 kiểu vòng lặp cho phép ta lặp lại các xử lý trong chương trình với một số lần cụ thể.

- Cú pháp:
```
for value in iterable:
    business logic 
```    

hoặc

```
for index in range(len(iterable)):
    business logic
```

Trong đó `iterable` là những cấu trúc dữ liệu có một hoặc nhiều phần tử như `List`,`Tuple`,`Set`, `Dictionary`,...

Ở ví dụ phần 1, ta có thể sử dụng hàm `range()` để tạo ra 1 dãy số tương ứng với `iterable` trong cú pháp. Ví dụ, `range(10)` sẽ tạo một dãy số từ 0 đến 9 (10 số).


```python
print(list(range(10))) # list chạy từ 0 đến 10 (không bao gồm 10)
print(list(range(2,10))) # list chạy từ 2 đến 10 (không bao gồm 10)
print(list(range(2,10,2))) # list chạy từ 2 đến 10 (không bao gồm 10), cách nhau 2 đơn vị
print(len(range(2,10,2))) # độ dài của range(2,10,2)
```

    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    [2, 3, 4, 5, 6, 7, 8, 9]
    [2, 4, 6, 8]
    4



```python
# Cách 1
li = list(range(6))
for value in li:
    print('*'*value)
```

    
    *
    **
    ***
    ****
    *****



```python
# Cách 2
for index in range(len(li)):
    print('*'*li[index])
```

    
    *
    **
    ***
    ****
    *****


**Bài tập**:

Cho 1 danh sách `li` gồm 10 phần tử từ 1 đến 10, trả về danh sách mới `li1` sao cho mỗi phần tử trong `li1` là bình phương của phần tử có trong `li` sử dụng `for`. 


```python
li = list(range(1,11)) # tạo 1 list gồm 10 phần tử từ 1 đến 10 và gán vào biến li
li1 = [] # khởi tạo 1 list rỗng gán vào biến li1
for val in li: # với từng giá trị trong biến li
    li1.append(val**2) # nối giá trị bình phương của phần tử trong li vào li1
print(li)
print(li1)
```

    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]



```python
li1 = [] #khởi tạo 1 list rỗng gán vào biến li1
for idx in range(len(li)): # với từng index các phần tử trong biến i
    li1.append(li[idx]**2) # nối giá trị bình phương của phần tử trong li vào li1
print(li)
print(li1)
```

    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]


Thông thường, nếu số lần lặp là cố định thì vòng lặp `for` khuyến khích sử dụng, còn nếu số lần lặp không cố định thì nên sử dụng vòng lặp `while` dưới đây.

### 2. Vòng lặp `while`

- Cú pháp
```
while condition(True/False):
    business logic
```


```python
i = 0
while i < 6:
    print('*'*i)
    i += 1
```

    
    *
    **
    ***
    ****
    *****


**Bài tập**:

Cho 1 danh sách `li` gồm 10 phần tử từ 1 đến 10, trả về danh sách mới `li1` sao cho mỗi phần tử trong `li1` là bình phương của phần tử có trong `li` sử dụng `while`. 


```python
li = list(range(1,11)) # tạo 1 list gồm 10 phần tử từ 1 đến 10 và gán vào biến li
li1 = [] # khởi tạo 1 list rỗng gán vào biến li1
index = 0
while index < len(li): # với giá trị của index nhỏ hơn độ dài biến li
    li1.append(li[index]**2) # nối giá trị bình phương của phần tử trong li vào li1
    index += 1
print(li)
print(li1)
```

    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]


## III. CÂU LỆNH ĐIỀU KIỆN

Câu lệnh điều kiện trong Python sẽ thực thi các tính toán hoặc hành động tùy thuộc vào điều kiện ràng buộc là đúng hay sai. Các điều kiện ràng buộc này được mô tả thông qua toán tử so sánh và toán tử luận lý chúng ta đã học trong bài trước. Nếu kết quả của các phép so sánh hoặc luận lý này là  True, các khối `business logic` bên trong kết quả đó mới được thực hiện.

- Cú pháp:
```
if condition(True/False):
    business logic
elif condition(True/False): # --> optional
    business logic
elif condition(True/False): # --> optional
    business logic
elif condition(True/False): # --> optional
    business logic
    ....
else:
    business logic # --> optional
```


```python
x = 5
y = 5
if x < y:
    print("x is smaller than y") # câu lệnh này không được thực thi vì x < y == False
elif x > y:
    print("x is larger than y") # câu lệnh này không được thực thi vì x > y == False
else:
    print("x is equal to y") # câu lệnh này không được thực thi vì x > y == True
```

    x is equal to y


## IV. HÀM (FUNCTION)

Hàm (function) là một khối lệnh đặc biệt có thể gọi để sử dụng ở các nơi khác nhau trong chương trình. Hàm còn có một tác dụng vô cùng quan trọng nữa là tránh việc phải lặp lại code để thực thi những tác vụ tương tự nhau, từ đó giúp cho ta có thể viết mã gọn hơn và đặc biệt có thể tái sử dụng cũng như quản lý mã nguồn chương trình dễ dàng hơn. 

Trong bài học trước, chúng ta đã làm quen với một số hàm có sẵn. Vậy để có thể tạo ra 1 hàm tự định nghĩa thì làm như thế nào? Ta cùng tham khảo cú pháp dưới đây:

- Cú pháp
```
def function_name(arg1, arg2, ...):
    business logic
    return #-->  optional
```

Lưu ý:
- `arg` là các tham số truyền vào hàm. Một hàm có thể có 0, 1 hoặc nhiều tham số và các tham số này được ngăn cách nhau bởi dấu phẩy. 
- Các biến và tham số của hàm chỉ có phạm vi trong hàm. Thời gian tồn tại của biến là khoảng thời gian mà biến đó xuất hiện trong bộ nhớ. Khi hàm được thực thi thì biến sẽ tồn tại. Biến bị hủy khi chúng ta thoát khỏi hàm. Hàm không nhớ giá trị của biến trong những lần gọi hàm trước đó.
- `return` dùng để trả về một giá trị (hoặc một biểu thức), hoặc đơn giản là trả về "không gì cả". Khi lệnh `return` được thực thi, hàm sẽ kết thúc. Tuy nhiên, `return` là lệnh không bắt buộc phải có trong thân hàm.


```python
def print_asterisk(number):
    for i in range(number):
        print('*'*i)
```


```python
print_asterisk(6)
```

    
    *
    **
    ***
    ****
    *****


**Bài tập**:

Viết 1 hàm tìm giá trị lớn nhất của 1 list các số nguyên. 


```python
def max_list(li):
    return max(li)
```


```python
def max_list1(li):
    max_num = 0
    for value in li:
        if max_num < value:
            max_num = value
    return max_num
```


```python
max_list([1,2,99,6])
```




    99




```python
max_list1([1,2,99,6])
```




    99



Lưu ý, ta có thể thêm mô tả về hàm bằng cách sử dụng `'''` hoặc `"""` như cách ta viết chú thích trên nhiều dòng ở vị trí giữa `def function_name()` và `business logic`.


```python
def max_list(li):
    """
    Return maximum number of a list
    """
    return max(li)
```

Ngoài ra, trong Python ta có 1 khái niệm hàm khác, đó là **Hàm vô danh**. Nếu các hàm bình thường được định nghĩa bằng cách sử dụng từ khóa `def` và có tên hàm, thì hàm vô danh được định nghĩa bằng cách sử dụng từ khóa `lambda`. Đó cũng là lí do mà hàm vô danh còn được gọi là hàm Lambda.
- Cú pháp:
`lambda parameters: business logic`

Lưu ý, hàm vô danh có thể có nhiều tham số nhưng chỉ có 1 biểu thức trả về. 
Khi bạn muốn biểu diễn các hàm số đơn giản một cách ngắn gọn hơn, hàm vô danh là 1 sự lựa chọn hoàn hảo. Tuy nhiên, khi muốn xây dưng các hàm số phức tạp với nhiều biểu thức và phép tính toán khác nhau thì hàm bình thường sẽ là sự lựa chọn tốt hơn.




```python
def square(x):
    return x**2
```


```python
square1 = lambda x : x**2
```


```python
square(2)
```




    4




```python
square1(2)
```




    4




```python
li = list(range(1,11))
li1 = list(map(lambda a: a**2 , li))
print(li)
print(li1)
```

    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]


## V. BAO HÀM (COMPREHENSION)

Bao hàm (Comprehension) là một tính năng tuyệt vời của Python giúp bạn giảm được nhiều dòng code và cách tạo ra dữ liệu mới (kiểu list/set/tuple/dictionary) dựa vào dữ liệu cũ theo một điều kiện nào đó chỉ trong 1 dòng. Dữ liệu mới có thể ở cấu trúc dữ liệu list, set, tuple, hoặc dictionary tuy theo cú pháp định nghĩa. Không chỉ giúp ta có thể viết mã ngắn gọn hơn, tốc độ xử lý trên cùng 1 tác vụ cũng chứng minh sử dụng bao hàm nhanh hơn.

- Cú pháp:
    - List comprehension: `[expression for variable in iterable]`
    - Set comprehension: `{expression for variable in iterable}`
    - Tuple comprehension: `tuple(expression for variable in iterable)`
    - Dictionary comprehension: `{key:value for variable in iterable]`
    
Lưu ý: ta có thể thêm các điều kiện thông qua câu lệnh điều kiện `if else` với bao hàm, ví dụ cú pháp với list comprehension:
- `[expression for variable in iterable if condition]`
hoặc
- `[expression if condition else else-expression for variable in iterable ]`


```python
def square_list(li): 
    '''
    Hàm tính bình phương từng phần tử trong 1 danh sách
    Trả về 1 danh sách mới chứa bình phương từng phần tử 
    '''
    li1 = []
    for value in li:
        li1.append(value**2)
    return li1

def square_list1(li): 
    '''
    Hàm tính bình phương từng phần tử trong 1 danh sách
    Trả về 1 danh sách mới chứa bình phương từng phần tử 
    '''
    li1 = []
    for value in li:
        li1.append(square(value))
    return li1

def square_list2(li):
    return [square(x) for x in li]
```


```python
li = [1,2,3]
print(square_list(li)) # list comprehension
print(square_list1(li))
print(square_list2(li))
```

    [1, 4, 9]
    [1, 4, 9]
    [1, 4, 9]



```python
[square(x) for x in li if x%2 == 0] # list comprehension kết hợp điều kiện
```




    [4]




```python
[square(x) if x%2 == 0 else x for x in li ] # list comprehension kết hợp điều kiện
```




    [1, 4, 3]




```python
[square(x) if x%2 == 0 else x if x > 2 else 0 for x in li ] # list comprehension kết hợp điều kiện
```




    [0, 4, 3]




```python
{square(x) for x in li} # set comprehension
```




    {1, 4, 9}




```python
tuple(square(x) for x in li) # tuple comprehension
```




    (1, 4, 9)




```python
{x: square(x) for x in li} # dictionary comprehension
```




    {1: 1, 2: 4, 3: 9}



Trong các bài tiếp theo, chúng ta sẽ cùng nhau tìm hiểu 1 số thư viện bổ trợ cho Python trong việc thao tác, xử lý, phân tích, và trực quan hoá dữ liệu.
